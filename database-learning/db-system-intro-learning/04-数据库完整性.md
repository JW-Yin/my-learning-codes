# 《数据库系统概论（第5版）》第五章 数据库完整性大纲
## 数据库完整性 是保证数据库中数据的正确性（符合现实语义）、有效性（在合法范围）和相容性（表间数据无矛盾）
## 第5章 数据库完整性

### 5.1 实体完整性

#### 5.1.1 定义实体完整性
- **关系模型的实体完整性规则**
  - 若属性（或属性组）A是基本关系R的主属性，则A不能取空值
  - 空值：不知道、不存在或无意义的值
- **CREATE TABLE语句中的实体完整性定义**
  - PRIMARY KEY约束
  - 单属性主码：列级约束或表级约束
  - 多属性主码：只能定义为表级约束
- **示例**
  ```sql
  -- 列级约束
  CREATE TABLE Student (
      Sno CHAR(9) PRIMARY KEY,
      ...
  );
  
  -- 表级约束
  CREATE TABLE SC (
      Sno CHAR(9),
      Cno CHAR(4),
      Grade SMALLINT,
      PRIMARY KEY (Sno, Cno)
  );
  ```

#### 5.1.2 实体完整性检查和违约处理
- **检查时机**
  - 执行INSERT操作时
  - 对主码列执行UPDATE操作时
- **检查内容**
  - 主码值是否唯一
  - 主码的各个属性是否为空
- **违约处理**
  - 拒绝执行操作（插入或修改）
  - 提示错误信息
- **检查方法**
  - 全表扫描（数据量小时）
  - 索引检查（建立主码索引，提高检查效率）

### 5.2 参照完整性

#### 5.2.1 定义参照完整性
- **关系模型的参照完整性规则**
  - 若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码K相对应，则对于R中每个元组在F上的值必须：
    - 取空值（F的每个属性值均为空值）
    - 等于S中某个元组的主码值
- **FOREIGN KEY约束**
  - 定义外码
  - 指定被参照表及参照列
- **示例**
  ```sql
  CREATE TABLE SC (
      Sno CHAR(9),
      Cno CHAR(4),
      Grade SMALLINT,
      PRIMARY KEY (Sno, Cno),
      FOREIGN KEY (Sno) REFERENCES Student(Sno),
      FOREIGN KEY (Cno) REFERENCES Course(Cno)
  );
  ```

#### 5.2.2 参照完整性检查和违约处理
- **破坏参照完整性的情况**
  - 参照表中插入元组：被参照表不存在对应元组
  - 修改参照表的外码值：被参照表不存在对应元组
  - 删除被参照表的元组：参照表中存在对应元组
  - 修改被参照表的主码值：参照表中存在对应元组
- **违约处理策略**
  - **拒绝执行（NO ACTION）**：不允许执行该操作（默认策略）
  - **级联操作（CASCADE）**：删除/修改所有相关的元组
  - **设置为空值（SET NULL）**：将相关外码值设为空值
- **外码约束的定义**
  - 可指定违约处理方式
  ```sql
  CREATE TABLE SC (
      Sno CHAR(9),
      Cno CHAR(4),
      Grade SMALLINT,
      PRIMARY KEY (Sno, Cno),
      FOREIGN KEY (Sno) REFERENCES Student(Sno)
          ON DELETE CASCADE    -- 删除Student元组时级联删除SC元组
          ON UPDATE CASCADE,   -- 更新Student.Sno时级联更新SC.Sno
      FOREIGN KEY (Cno) REFERENCES Course(Cno)
          ON DELETE NO ACTION  -- 删除Course元组时拒绝执行（若SC有对应元组）
          ON UPDATE CASCADE    -- 更新Course.Cno时级联更新SC.Cno
  );
  ```

### 5.3 用户定义的完整性

#### 5.3.1 属性上的约束条件
- **NOT NULL约束**
  - 列值不允许为空
  ```sql
  CREATE TABLE Student (
      Sno CHAR(9) PRIMARY KEY,
      Sname CHAR(20) NOT NULL,
      ...
  );
  ```
- **UNIQUE约束**
  - 列值必须唯一
  ```sql
  CREATE TABLE Student (
      Sno CHAR(9) PRIMARY KEY,
      Sname CHAR(20) NOT NULL,
      Siden CHAR(18) UNIQUE,  -- 身份证号唯一
      ...
  );
  ```
- **CHECK约束**
  - 指定列值应满足的条件
  ```sql
  CREATE TABLE Student (
      Sno CHAR(9) PRIMARY KEY,
      Sname CHAR(20) NOT NULL,
      Ssex CHAR(2) CHECK(Ssex IN ('男', '女')),  -- 性别只能是'男'或'女'
      Sage SMALLINT CHECK(Sage >= 15 AND Sage <= 45),  -- 年龄在15-45之间
      ...
  );
  ```

#### 5.3.2 元组上的约束条件
- **元组级CHECK约束**
  - 可以定义不同属性之间的约束条件
  ```sql
  CREATE TABLE Student (
      Sno CHAR(9) PRIMARY KEY,
      Sname CHAR(20) NOT NULL,
      Ssex CHAR(2),
      Sage SMALLINT,
      Sdept CHAR(20),
      CHECK (Ssex = '女' OR Sname NOT LIKE 'Ms.%')  -- 男生名字不能以Ms.开头
  );
  ```

### 5.4 完整性约束命名子句
- **CONSTRAINT子句**
  - 为完整性约束命名
  - 便于增加和删除约束
- **约束命名格式**
  ```sql
  CONSTRAINT <完整性约束条件名> <完整性约束条件>
  ```
- **示例**
  ```sql
  CREATE TABLE Student (
      Sno CHAR(9) CONSTRAINT PK_Student PRIMARY KEY,
      Sname CHAR(20) CONSTRAINT NN_Sname NOT NULL,
      Ssex CHAR(2) CONSTRAINT CK_Ssex CHECK(Ssex IN ('男', '女')),
      Sage SMALLINT CONSTRAINT CK_Sage CHECK(Sage >= 15 AND Sage <= 45),
      Sdept CHAR(20),
      CONSTRAINT CK_Student CHECK (Ssex = '女' OR Sname NOT LIKE 'Ms.%')
  );
  ```
- **修改完整性约束**
  - 使用ALTER TABLE语句
  ```sql
  -- 增加约束
  ALTER TABLE Student
      ADD CONSTRAINT CK_Sage2 CHECK(Sage < 30);
      
  -- 删除约束
  ALTER TABLE Student
      DROP CONSTRAINT CK_Sage2;
      
  -- 修改约束（先删除后添加）
  ALTER TABLE Student
      DROP CONSTRAINT CK_Sage;
  ALTER TABLE Student
      ADD CONSTRAINT CK_Sage CHECK(Sage >= 16 AND Sage <= 40);
  ```

### 5.5 域中的完整性限制
- **域的概念**
  - 一组具有相同数据类型的值的集合
- **CREATE DOMAIN语句**
  - 创建用户定义的域
  - 可在域上定义完整性约束
- **示例**
  ```sql
  -- 创建域
  CREATE DOMAIN GenderDomain CHAR(2)
      CHECK (VALUE IN ('男', '女'));
      
  CREATE DOMAIN AgeDomain SMALLINT
      DEFAULT 18
      CHECK (VALUE >= 15 AND VALUE <= 45);
      
  -- 使用域
  CREATE TABLE Student (
      Sno CHAR(9) PRIMARY KEY,
      Sname CHAR(20) NOT NULL,
      Ssex GenderDomain,      -- 使用GenderDomain域
      Sage AgeDomain,         -- 使用AgeDomain域
      Sdept CHAR(20)
  );
  ```

### 5.6 断言
- **断言的概念**
  - 更具一般性的约束
  - 可以定义涉及多个表或聚集操作的约束
- **CREATE ASSERTION语句**
  - 创建断言
  ```sql
  CREATE ASSERTION <断言名> <CHECK子句>
  ```
- **示例**
  ```sql
  -- 限制数据库课程最多60名学生选修
  CREATE ASSERTION ASSE_SC_DB_NUM
      CHECK (60 >= (SELECT COUNT(*)
                    FROM Course, SC
                    WHERE Course.Cno = SC.Cno AND Course.Cname = '数据库'));
                    
  -- 限制每个学期每门课程最多60名学生选修
  CREATE ASSERTION ASSE_SC_CNUM1
      CHECK (60 >= ALL (SELECT COUNT(*)
                        FROM SC
                        GROUP BY Cno, Semester));
                        
  -- 限制每个学生一学期选修课程总学分不超过20
  CREATE ASSERTION ASSE_SC_SUM_CREDIT
      CHECK (20 >= ALL (SELECT SUM(Ccredit)
                        FROM SC, Course
                        WHERE SC.Cno = Course.Cno
                        GROUP BY Sno, Semester));
  ```
- **删除断言**
  ```sql
  DROP ASSERTION <断言名>
  ```

### 5.7 触发器
#### 5.7.1 定义触发器
- **触发器的概念**
  - 用户定义在关系表上的一类由事件驱动的特殊过程
  - 由服务器自动激活
  - 可以进行更复杂的检查和操作，实现更精细的完整性控制
- **触发器组成**
  - 触发事件：INSERT、DELETE、UPDATE
  - 触发时间：BEFORE、AFTER
  - 触发条件：WHEN子句指定
  - 触发动作体：触发器被激活后执行的操作
- **CREATE TRIGGER语句**
  ```sql
  CREATE TRIGGER <触发器名>
      {BEFORE | AFTER} <触发事件> ON <表名>
      [REFERENCING <旧/新别名>]
      [FOR EACH {ROW | STATEMENT}]
      [WHEN <触发条件>]
      <触发动作体>
  ```
- **示例**
  ```sql
  -- 当对表SC的Grade属性进行修改时，若分数增加了10%，则记录
  CREATE TRIGGER SC_T
      AFTER UPDATE OF Grade ON SC
      REFERENCING
          OLDROW AS OldTuple,
          NEWROW AS NewTuple
      FOR EACH ROW
      WHEN (NewTuple.Grade >= 1.1 * OldTuple.Grade)
          INSERT INTO SC_U(Sno, Cno, OldGrade, NewGrade)
          VALUES(OldTuple.Sno, OldTuple.Cno, OldTuple.Grade, NewTuple.Grade);
          
  -- 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中
  CREATE TRIGGER Student_Count
      AFTER INSERT ON Student
      REFERENCING
          NEW TABLE AS DELTA
      FOR EACH STATEMENT
          INSERT INTO StudentInsertLog(Numbers)
          SELECT COUNT(*) FROM DELTA;
  ```

#### 5.7.2 激活触发器
- **触发器的执行顺序**
  - 同一表上同类触发器（如BEFORE UPDATE）按创建时间顺序执行
  - 不同类触发器执行顺序：BEFORE触发器 → SQL语句 → AFTER触发器
- **触发条件检查**
  - 若省略WHEN子句，则触发动作体在触发器激活后立即执行
  - 若指定WHEN子句，则先检查条件，条件为真时才执行触发动作体

#### 5.7.3 删除触发器
- **DROP TRIGGER语句**
  ```sql
  DROP TRIGGER <触发器名> ON <表名>
  ```

### 5.8 小结
- **数据库完整性的重要性**
  - 保证数据库中数据的正确性、有效性和相容性
- **完整性约束类型**
  - 实体完整性：主码非空且唯一
  - 参照完整性：外码要么为空，要么等于被参照表的主码值
  - 用户定义完整性：满足具体应用语义的约束
- **完整性控制机制**
  - 完整性约束定义：CREATE TABLE、ALTER TABLE、CREATE DOMAIN等
  - 完整性约束命名：CONSTRAINT子句
  - 断言：CREATE ASSERTION
  - 触发器：CREATE TRIGGER
- **完整性检查与违约处理**
  - 执行操作时自动检查
  - 违约处理：拒绝执行、级联操作、设置为空值等
- **触发器的高级功能**
  - 事件驱动的完整性控制
  - 可实现复杂的业务规则和数据约束

---
