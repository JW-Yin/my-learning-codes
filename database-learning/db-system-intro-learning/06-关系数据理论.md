# 《数据库系统概论（第5版）》第六章 关系数据理论大纲

## 第6章 关系数据理论

### 6.1 问题的提出
- **关系模式可能存在的问题**
  - 数据冗余：同一信息在数据库中多次重复存储
  - 更新异常：修改数据时可能只修改部分副本，导致数据不一致
  - 插入异常：无法插入某些特定信息
  - 删除异常：删除某些信息时可能丢失其他有用信息
- **问题的根源**
  - 关系模式设计不合理
  - 属性间存在不合适的数据依赖关系
- **解决方法**
  - 规范化理论
  - 设计合适的关系模式

### 6.2 规范化

#### 6.2.1 函数依赖
- **函数依赖定义**
  - 设R(U)是属性集U上的关系模式，X、Y是U的子集
  - 若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等
  - 则称X函数确定Y，或Y函数依赖于X，记作X→Y
- **函数依赖类型**
  - **平凡函数依赖**：如果Y⊆X，则X→Y是平凡函数依赖
  - **非平凡函数依赖**：如果Y不是X的子集，则X→Y是非平凡函数依赖
  - **完全函数依赖**：如果X→Y，且对于X的任何一个真子集X'，都有X'不能确定Y
  - **部分函数依赖**：如果X→Y，但Y不完全函数依赖于X
  - **传递函数依赖**：如果X→Y，Y→Z，且Y不函数依赖于X，Z不包含于Y，则称Z对X传递函数依赖

#### 6.2.2 码
- **候选码（Candidate Key）**
  - 设K为R<U,F>中的属性或属性组合
  - 如果U完全函数依赖于K，则K为R的候选码
- **主码（Primary Key）**
  - 若候选码多于一个，则选定其中一个为主码
- **主属性与非主属性**
  - 包含在任何一个候选码中的属性称为主属性
  - 不包含在任何候选码中的属性称为非主属性
- **全码（All-Key）**
  - 整个属性组都是码，称为全码
- **外码（Foreign Key）**
  - 关系模式R中属性（组）X并非R的码，但X是另一个关系模式的码

#### 6.2.3 范式
- **范式的概念**
  - 关系数据库中的关系需要满足一定的规范化要求
  - 不同程度的规范化要求称为不同的范式
- **范式类型**
  - 第一范式（1NF）
  - 第二范式（2NF）
  - 第三范式（3NF）
  - BC范式（BCNF）
  - 第四范式（4NF）

#### 6.2.4 2NF
- **2NF定义**
  - 若R∈1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R∈2NF
- **1NF的问题**
  - 可能存在部分函数依赖，导致数据冗余和操作异常
- **1NF到2NF的转换**
  - 消除非主属性对码的部分函数依赖

#### 6.2.5 3NF
- **3NF定义**
  - 若R∈2NF，且每一个非主属性不传递依赖于码，则R∈3NF
- **2NF的问题**
  - 可能存在传递函数依赖
- **2NF到3NF的转换**
  - 消除非主属性对码的传递函数依赖

#### 6.2.6 BCNF
- **BCNF定义**
  - 若R∈3NF，且每一个决定因素都包含码，则R∈BCNF
- **BCNF的性质**
  - 所有非主属性对每一个码都是完全函数依赖
  - 所有主属性对每一个不包含它的码也是完全函数依赖
  - 没有任何属性完全函数依赖于非码的任何一组属性
- **3NF到BCNF的转换**
  - 消除主属性对码的部分和传递函数依赖

#### 6.2.7 多值依赖
- **多值依赖定义**
  - 设R(U)是属性集U上的关系模式，X、Y、Z是U的子集，且Z=U-X-Y
  - 如果对R(U)的任一关系r，给定的一对(x,z)值，有一组Y的值与之对应，这组值仅仅决定于x值而与z值无关
  - 则称Y多值依赖于X，记作X→→Y
- **多值依赖的性质**
  - 对称性：若X→→Y，则X→→Z，其中Z=U-X-Y
  - 传递性：若X→→Y，Y→→Z，则X→→Z-Y
- **平凡多值依赖**
  - 若X→→Y，且Z=∅，或Y⊆X，则称X→→Y为平凡多值依赖

#### 6.2.8 4NF
- **4NF定义**
  - 关系模式R<U,F>∈1NF，如果对于R的每个非平凡多值依赖X→→Y（Y不是X的子集，且X不包含码），X都含有码，则R∈4NF
- **4NF的性质**
  - 限制关系模式的属性之间不允许有非平凡且非函数依赖的多值依赖

#### 6.2.9 规范化小结
- **规范化过程**
  - 1NF → 2NF：消除非主属性对码的部分函数依赖
  - 2NF → 3NF：消除非主属性对码的传递函数依赖
  - 3NF → BCNF：消除主属性对码的部分和传递函数依赖
  - BCNF → 4NF：消除非平凡且非函数依赖的多值依赖
- **规范化的目的**
  - 消除数据冗余和操作异常
  - 设计出合理的关系模式
- **规范化程度选择**
  - 不是规范化程度越高越好
  - 需要根据实际应用需求权衡

### 6.3 数据依赖的公理系统
- **Armstrong公理系统**
  - **自反律（Reflexivity）**：若Y⊆X⊆U，则X→Y为F所蕴含
  - **增广律（Augmentation）**：若X→Y为F所蕴含，且Z⊆U，则XZ→YZ为F所蕴含
  - **传递律（Transitivity）**：若X→Y及Y→Z为F所蕴含，则X→Z为F所蕴含
- **推理规则**
  - **合并规则（Union）**：若X→Y，X→Z，则X→YZ
  - **伪传递规则（Pseudotransitivity）**：若X→Y，WY→Z，则XW→Z
  - **分解规则（Decomposition）**：若X→Y，且Z⊆Y，则X→Z
- **闭包**
  - **函数依赖集F的闭包F⁺**：所有被F逻辑蕴含的函数依赖的集合
  - **属性集X关于函数依赖集F的闭包X⁺_F**：能由F根据Armstrong公理推导出的所有函数依赖X→A_i中A_i的集合
- **最小依赖集（最小覆盖）**
  - **定义**：满足以下条件的函数依赖集G
    - G中每个函数依赖的右边都是单个属性
    - G中没有冗余的函数依赖
    - G中每个函数依赖的左边没有冗余的属性
  - **求解步骤**
    1. 将F中的所有函数依赖的右边化为单属性
    2. 去掉F中冗余的函数依赖
    3. 去掉各函数依赖左边的冗余属性

### 6.4 模式的分解
#### 6.4.1 模式分解的三个定义
- **分解具有无损连接性**
  - 关系模式R<U,F>的一个分解ρ={R₁<U₁,F₁>, R₂<U₂,F₂>, ..., R_k<U_k,F_k>}
  - 若R与R₁、R₂、...、R_k在自然连接后仍相等，则称分解ρ具有无损连接性
- **分解保持函数依赖**
  - 若F⁺ = (∪F_i)⁺，则称分解ρ保持函数依赖
- **分解既具有无损连接性又保持函数依赖**
  - 同时满足上述两个条件

#### 6.4.2 分解的无损连接性和保持函数依赖性
- **无损连接性的判定**
  - **表格法（Chase算法）**
    1. 构造初始表格
    2. 根据函数依赖修改表格
    3. 若某一行全为a，则分解具有无损连接性
  - **定理判定法**
    - 对于分解ρ={R₁, R₂}，若R₁∩R₂→R₁-R₂或R₁∩R₂→R₂-R₁成立，则ρ具有无损连接性
- **保持函数依赖的判定**
  - 检查F中的每一个函数依赖X→Y是否在G=∪F_i中逻辑蕴含

#### 6.4.3 模式分解的算法
- **达到3NF且保持函数依赖的分解算法**
  1. 求F的最小依赖集G
  2. 找出不在G中出现的属性，将它们单独分解成一个关系模式
  3. 对G中的函数依赖，将相同左部的属性合并
  4. 得到的每个关系模式都是3NF，且保持函数依赖
- **达到3NF且既具有无损连接性又保持函数依赖的分解算法**
  1. 按上述算法得到保持函数依赖的3NF分解
  2. 若分解中某个关系模式包含原关系模式的码，则已满足要求
  3. 否则，将原关系模式的码作为一个新的关系模式加入分解
- **达到BCNF且具有无损连接性的分解算法**
  1. 检查R是否已属于BCNF，若是则结束
  2. 找出R中违反BCNF的函数依赖X→Y
  3. 将R分解为R₁=XY和R₂=R-Y
  4. 对R₁和R₂递归应用上述过程

### 6.5 小结
- **关系数据理论的核心问题**
  - 如何设计合适的关系模式
- **规范化理论**
  - 基于函数依赖和多值依赖
  - 从1NF到4NF的规范化过程
- **数据依赖的公理系统**
  - Armstrong公理系统
  - 函数依赖集的闭包和最小依赖集
- **模式分解**
  - 无损连接性和保持函数依赖
  - 各种规范化级别的分解算法
- **理论指导实践**
  - 关系数据理论为数据库设计提供理论指导
  - 实际应用中需要根据具体情况进行调整

---